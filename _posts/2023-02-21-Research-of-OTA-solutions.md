---
layout: post
title: "Research of OTA Solutions: RAUC, Mender and OSTree"
---
# Overview

RAUC, Mender, and OSTree are all popular solutions for over-the-air
(OTA) embedded system software updates. They differ in terms of their
features, architecture, and performance, making it important to choose
the right solution based on the requirements of a particular project.

RAUC is a flexible and efficient tool for OTA updates that uses a bundle
concept to package and distribute updates. It is a simple, but powerful
tool that provides a reliable way to update embedded systems.

Mender, on the other hand, is a fully featured OTA solution that
provides a comprehensive set of tools for updating embedded systems. It
offers a complete OTA update process, including server-side and
client-side components, as well as management tools for deploying and
monitoring updates.

OSTree is an OTA update solution that is designed to provide fast and
secure updates for embedded systems. It uses a Git-like system to manage
software versions, which allows for easy rollback in case of problems
with an update. Additionally, OSTree provides a flexible and efficient
system for distributing updates that can be tailored to specific
requirements.

Each of these solutions has its own strengths and weaknesses, and it is
important to choose the right one based on the needs of a specific
project. This document will provide a detailed comparison from different
aspects to help in making an informed decision about which solution is
best for a project.

# Comparison of the three solutions

This section will have a horizontal comparison between the three update
projects from a few major aspects we usually use to evaluate an update
technology of embedded systems, followed by an evaluation of the pros
and cons of each system.

## Device Layout Scheme

<u>RAUC:</u>

Supports both “Symmetric A/B” (dual image update framework) or
“Asymmetric A/Recovery” (Single image update framework).

<u>Mender:</u>

Supports “Symmetric A/B” (dual image update framework) only.

<u>OSTree:</u>

Unlike the traditional schemes (Symmetric A/B or Asymmetric A/Recovery),
OSTree has no concept in a dual or single layout but uses a git-like
object repository to record and deploy complete file system trees.

<u>Notes:</u>

  > RAUC is more flexible than Mender with support on both
  > Symmetric/Asymmetric schemes.

  > OSTree is the most flexible one since it is able to have multiple
  > file system trees within one repository, only constraint is the
  > storage size.

## Filesystem Types

<u>RAUC:</u>

EXT4 for block devices.

UBIFS, UBIMG for MTD devices.

<u>Mender:</u>

No dependencies on a specific file system type, but depends on whether
it is supported by the bootloader.\[1\]

<u>OSTree:</u>

EXT4, BTRFS, XFS for block devices.

No preferred filesystems for MTD devices.

<u>Notes:</u>

  > Mender shows less dependencies on certain filesystems.

  > OSTree claims that it supports MTD devices, but no specific
  > implementation on a certain type of the filesystems on them.

## Deploy Mechanism

<u>RAUC:</u>

Pull/push packages via the network (HTTPS) or locally from a media e.g.
USB.

Supports streaming through built-in HTTPS or via casync, no intermedia
storage is required.

Supports delta updates.

<u>Mender:</u>

Pull/push packages via the network (HTTPS) or locally from a media e.g.
USB.

Distributed devices must connect to server through Mender Gateway \[2\]

Two modes are implemented.

*managed mode*: client is a daemon and will poll the server for updates

*standalone mode*: updates are triggered locally from physical media or
pulling from network

Supports HTTPS streaming, no intermedia storage is required.

Layer meta-mender-commercial is required for delta updates, but it is in
commercial plan. \[2\]

<u>OSTree:</u>

Pre-deploy process (migration from bare repository to archive
repository) is required after the images or packages are generated by
the build system: Commit the packages output from a build system into a
bare repository, and then export content into the archive repository for
use by the clients.

Update through pulling from a remote repository for a specific commit
(“refs”) into the local OSTree repository via HTTPS if the commit does
not exist locally or update a commit (“refs”) from the local OSTree
repository.

Supports HTTPS streaming, no intermedia storage is required.

For delta updates, when performing a pull for a specific commit, just
fetching each individual object that we do not have - only download
changed files (gzip-compressed)

<u>Notes:</u>

  > Mender needs commercial plans (Mender Enterprise and/or Mender
  > Professional) to support some advanced features like delta update
  > and allowing distributed devices to connect with Mender update
  > server.

  > OSTree supports delta update by its git-like nature.

## Artifacts Management And Packaging

### Artifact Format & Compression

<u>RAUC:</u>

The RAUC artifacts are managed in image-based "bundles"
(filesystems+manifest), followed by a signature plus signer's
certificate (signature+certificate, in CMS\[3\] format).

Different bundle types are available: Clear, Verity or Crypt.

File system is a SquashFS image that supports mounting without
unpacking.

<u>Mender:</u>

Mender uses a specific file format - Mender Artefact (\*.mender),
contains software images and metadata.

Mender Artefact is not compressed, but filesystem image and metadata
inside are gzip-compressed.

<u>OSTree:</u>

OSTree artifacts are managed in git-like objects.

commit object: contains metadata of history of binary builds.

dirtree object: contains subdirectory metadata of a directory.

dirmeta object: contains metadata of a directory.

content object: header with uid, gid, mode, symlinks, extended
attributes + the file content + hash (SHA256).

xattrs objects: for repository type bare-split-xattrs to carry xattrs in
separate objects.

Content object is gzip-compresses. Metadata objects are stored
uncompressed.

<u>Notes:</u>

  > Three solutions have their own proprietary formats for artifact
  > management.

  > Mender/OSTree needs to unpack the gzip while RAUC can mount the
  > SquashFS directly.

### Signing/Verifying

<u>RAUC:</u>

The signer's certificate (X.509 PEM) location is defined in the system
conf file \[4\].

Before installation, verify the signer's certificate against the linux
keyring and then parse the public key to verify the bundle signature.

Signature algorithm can be RSA 4096 or ECDSA 256.

<u>Mender:</u>

The signer's public key location is defined in the system conf file
\[4\].

Before installation, Mender uses the public key to verify the signature
of artifacts (No linux keyring is involved to verify the public key
before that)

Signature algorithm can be RSA \>3072 or ECDSA 256.

mender-artifact tool supports Google Cloud Key Management, to sign
artifacts using keys in Cloud Key Management, allowing developers to
sign artifacts without accessing the private signing key.

<u>OSTree:</u>

OSTree signs each of the commits using GPG.

Client verifies the signature of the commit before deploying it.

However, the provisioning of the public key is not considered by OSTree.

<u>Notes:</u>

  > RAUC verifies the public key against Linux keyring before using it
  > to verify the signature.

  > Mender supports cloud key management.

  > OSTree is using GPG without PKI for signatures and the way to
  > provision the public key is the integrator’s responsibility.

### Integrity Checks

<u>RAUC:</u>

Type Verity bundles provide additional filesystem integrity checks
leveraging dm-verity, a dm-verity hash tree over the SquashFS image and
manifest is contained in CMS\[3\], integrity checks are applied via
dm-verity.

<u>Mender:</u>

N/A.

Mender does not have built-in support for filesystem integrity checks.

<u>OSTree:</u>

Each OSTree content object has a checksum (SHA256) that includes the
file content and metadata (uid, gid, mode and extended attributes).

An extension with IMA signatures and policies to provide additional
integrity checks (not working with EVM due to its extended attributes
causing object corruption).

<u>Notes:</u>

  > RAUC provides options for filesystem integrity checks based on
  > dm-verity while Mender does not.

  > OSTree provides SHA256 checksum includes file content and
  > metadata, plus IMA with additional file content integrity check
  > and file content plus metadata signature check.

### Encrypt/Decrypt

<u>RAUC:</u>

Type Crypt bundles provide bundle payload encrypt/decrypt leveraging
dm-crypt to encrypt/decrypt bundle payload (symmetric key is a plain
text in manifest, AES-256) while manifest is encrypted by recipient's
public key (RSA 4096, ECC 256).

<u>Mender:</u>

N/A

Mender does not have built-in support for encrypting artifacts.

<u>OSTree:</u>

N/A

OSTree does not have built-in support for encrypting
repo/commit/package.

<u>Notes:</u>

  > RAUC provides options for file system encryption based on dm-crypt
  > while Mender/OSTree does not.

## Installation

<u>RAUC:</u>

Both system/application updates are applied according to slot
definitions.

Slot is an abstraction to reflect a device, partition, volume or file by
various slot types.

Slot grouping for deactivating/updating/reactive a group of slots, the
operation within a slot group is atomic.

Slot configuration described in system config file \[4\].

RAUC handles a mapping between slot type and image type and looks for
the pre-defined method to install the bundles.

<u>Mender:</u>

System update depends on combinations of OS and hardware platform which
Mender supports (This is called a "Mender Board Integration").

Mender officially supports the most common Linux OSes, and has reference
implementations for specific devices \[5\].

Application update is extended per specific software package types
(apps, packages, containers or proxy deployment for peripherals via e.g.
USB-DFU) by Update Modules, which are independent scripts and can be
customized and installed separately.

<u>OSTree:</u>

For system update, OSTree supports recording and deploying complete
(bootable) filesystem trees

Atomic updates are guaranteed by atomically swapping a /boot symlink to
a new deployment /ostree/boot.foo directory.

For application update, installing a package, rather than changing the
currently running filesystem, it is possible to use OSTree underneath a
package system, the package manager could assemble a new filesystem tree
that layers the new packages on top of a base tree, record it in the
local OSTree repository, and then set it up for the next boot.

rpm-ostree is an example project for a package system that works with
OSTree.

<u>Notes:</u>

  > For a system update, Mender provides reference support for most of
  > the popular OSes and hardwares and is easy to start with. However,
  > it looks that RAUC is more flexible by introducing the abstraction
  > of "slot". OSTree has a fast and efficient update mechanism, due
  > to its unique design of using atomic commits and hard links. This
  > allows OSTree to perform updates quickly by only updating the
  > necessary files, rather than copying an entire new image to the
  > device.

  > For an application update, Mender is more flexible with the Update
  > Modules that like an add-on for creating a new or extending an
  > existing package type, while RAUS only supports installation
  > method pre-defined for each combination of slot types and image
  > types. OSTree provides a similar principle as Mender does, however
  > it needs an integration with a specific package system to support
  > it.

## Bootloader Integration

<u>RAUC:</u>

RAUC provides different interfaces to access the boot configuration and
environment variables.

Scripts for U-boot and GRUB, or boot chooser framework for Barebox

<u>Mender:</u>

Mender is built-in supported by GRUB, no patch is needed.

For U-boot, Mender provides special integration points for U-boot to
hook into so that Mender can be a part of the normal boot process.

<u>OSTree:</u>

OSTree provides both commands and APIs to manage the bootloader
configuration files and environment variables.

<u>Notes:</u>

  > Less integration work with GRUB and U-boot is required for Mender
  > than RAUC.

  > OSTree has less dependencies on specific bootloaders.

## Update Rollback

<u>RAUC:</u>

Rollback from a full backup in the inactive slot is supported (Symmetric
A/B scheme only).

<u>Mender:</u>

Rollback from a full backup in the inactive slot is supported.

<u>OSTree:</u>

When OSTree performs an update, it creates a new hard link for the new
version it downloaded. The hard link points to the actual data of the
new version, but gives it a new name in the file system. This way, the
new version is treated as a separate entity. When OSTree needs to
perform a rollback, it simply updates the boot configuration to point to
the previous version of the operating system. This is achieved by
changing the hard link to point to the desired snapshot. Because the
data is shared between hard links, the rollback is done in a matter of
milliseconds, and the system immediately boots into the previous
version.

<u>Notes:</u>

  > There is no significant difference between RAUC and Mender in
  > terms of a rollback from the inactive slot under the Symmetric A/B
  > scheme.

  > System snapshots implemented by hard links allows OSTree to
  > perform rollbacks in a fast and efficient manner with minimal
  > overhead and risk of data loss.

## Backend Update System Compatibility

<u>RAUC:</u>

RAUC supports both Eclipse hawkBit / AWS with integration with relevant
connect clients.

rauc-hawkbit client for hawkBit.

Upparat client for AWS IoT jobs.

Both are separate projects, Python-based apps and libraries.

D-Bus is used between RAUC and the integrated connect client.

<u>Mender:</u>

Mender is tied to Mender update server (built-in support with features
like Device Group, Phased rollout deployment, RBAC, Device
Authentication \[2\])

Connect client "Mender Connect" is ready for use with Mender update
service.

D-Bus is used between Mender Client and Mender Connect.

<u>OSTree:</u>

OSTree has a reference design for Uptane.

aktualizr: C++ implementation of Uptane OTA update client.

HERE OTA Connect: Uptane-compatible OTA server.

<u>Notes:</u>

  > Mender has its own connect client which is ready for and firmly
  > tied to Mender update service. The web-interface of Mender update
  > service which controls the backend update server is well-designed
  > and easy to use. Setting it up is done via Docker, which makes
  > initial set-up straightforward. But some of the advanced features
  > require a Mender Enterprise or Mender Professional plan which
  > means "not free".

  > RAUC can support both hawkBit or AWS and needs integration with
  > external connect client projects (rauc-hawkbit or Upparat).

  > Similarly, OSTree needs integration with external clients to
  > access a specific backend service. aktualizr with HERE OTA Connect
  > can be a reference.

  > For a demo with a backend service, Mender is ready-to-go, while
  > RAUC/OSTree needs an integration.

## Developer API & Command-Line Tool

<u>RAUC:</u>

For device-side, D-Bus interface is available.

RAUC has no server-side API.

The command-line tool "rauc" is to generate/sign/verify/install/fallback
for both device-side and server-side.

<u>Mender:</u>

For device-side, D-Bus interface for Mender client. Good documents for
API sets and example applications are available.

For server-side, Mender provides REST API for Mender server.
The command-line tool "mender-artifact" is to view, create, modify, sign
and verify artifacts for both device-side and server-side.

<u>OSTree:</u>

For device-side, D-Bus interface for updates, rollbacks, and repository
management.

Server-side APIs for a set of functions that can be used to implement an
OSTree repository server.

The command-line tool "ostree" is for updates, rollbacks, and repository
management.

<u>Notes:</u>

  > Mender has APIs for both device-side and server-side with the best
  > API reference guide.

  > RAUC has no API for server-side.

  > OSTree's server-side APIs are for repository management only, not
  > for general OTA management.

## Cryptographic API

<u>RAUC:</u>

OpenSSL, PKCS\#11.

<u>Mender:</u>

OpenSSL, PKCS\#11.

<u>OSTree:</u>

GPG, OpenSSL.

<u>Notes:</u>

  > OSTree is using GPG for commit signature instead of PKI.

## CI/CD Pipeline For Deployment

<u>RAUC:</u>

N/A

<u>Mender:</u>

Ready for GitHub Actions, GitLab CI/CD, Azure DevOps.

<u>OSTree:</u>

OSTree defines a model that allows to have different branches in a "dev"
repository to indicate different development stages and support
promoting commits from one to another through the CI/CD pipeline and
finally promotes to the "prod" repository for deployment.

However, this is just a concept of model (with some supporting scripts)
but integration with a CI/CD tool is required.

<u>Notes:</u>

  > Mender is ready for demo on deploying via CI/CD pipeline, OSTree
  > provides a prototype while RAUC has nothing for it.

## Footprints

<u>RAUC:</u>

The main binary is only approx. 512K.

<u>Mender:</u>

The main binary is about 6M.

<u>OSTree:</u>

Main library is less than 1M.

<u>Notes:</u>

  > All three systems are designed to be efficient and lightweight but
  > RAUC looks to have the smaller size. \[6\]

  > For OSTree, the size of the repository is more critical due to it
  > may contain multiple trees.

## Documentation & Guidelines

<u>RAUC:</u>

Usage guide, examples, scenarios and integration guide for Yocto,
PTXdist and buildroot.

An example for local update (Symmetric A/B) is ready for testing with
QEMU (with GRUB).

<u>Mender:</u>

Easy to get started with as there is good, clear and step-by-step
documentation on how to set up and integrate.

Provides reference implementations and demos on Raspberry Pi (3 Model
B/B+, 4 Model B), BeagleBone Black and QEMU.

Examples for deploying application/system/container update via
web-interface are ready for testing with QEMU.

<u>OSTree:</u>

Official website provides the concepts on how OSTree works and
prototypes on how to integrate with a build system and how to manage the
repositories, as well as an API reference and manual.

<u>Notes:</u>

  > Mender has the best documentation among the three and is easy to
  > start with an end-to-end OTA demo, while RAUC only provides some
  > certain examples to show a local update.

  > OSTree website tends to provide ideas, prototypes on integrations
  > with a steep learning curve, not user-friendly for beginners.

## Customization

<u>RAUC:</u>

Part of runtime behaviors of device-side clients can be configured via
parameters of the system config file \[4\].

Handles (scripts) for pre-install or post-install can be defined in the
system config file \[4\].

Hooks (scripts) can be defined in a bundle's manifest to add/replace
some functionalities during installation for a specific bundle.

Lack of documents for customization.

<u>Mender:</u>

Built-in customerization options are available through classes for both
update image features and Mender Client behaviors with good
documentation.

Supporting customized State Scripts (root file system script or artifact
script) which are able to be executed during transition of states (e.g.
Idle, Sync, Download, ArtifactInstall, ArtifactReboot, ArtifactCommit,
ArtifactRollback, ArtifactRollbackReboot, ArtifactFailure).

<u>OSTree:</u>

OSTree is not a full update client, instead a library focused on
git-like repository management.

It is fully flexible for customization with an update client (e.g.
aktualizr).

<u>Notes:</u>

  > Mender has more flexibility with options/classes for both update
  > image and client behaviors.

  > State Scripts are more general and useful than pre/post-install
  > scripts that RAUC is using because they can be run between any
  > state transition, not just (before/after) the install state.

  > OSTree normally works with an external update client, itself
  > doesn't provide more functionalities than repository management.
  > It is fully customized from this perspective.

## Version Compatibility

<u>RAUC:</u>

Compatibility to old versions is limited to "a reasonable level", but no
clear document on it.

<u>Mender:</u>

The compatibility between different versions of below components is well
documented:

Mender client and Yocto Project version

Mender client/server and Artifact format

Mender server and client API

Mender client and Mender connect

<u>OSTree:</u>

OSTree supports backward compatibility for older versions, but it is the
responsibility of the developer to ensure any deprecated features or
changes in behavior via the release notes.

<u>Notes:</u>

  > Mender has a clear picture on the compatibility between different
  > versions while RAUC/OSTree does not.

# Summary

This section summarizes the factors we discussed in the previous
comparison.

Below is a table for a quick review of the differences between RAUC,
Mender and OSTree.

## Table Of Comparison For Review

<table>
<thead>
<tr class="header">
<th><strong>Factors</strong></th>
<th><strong>RAUC</strong></th>
<th><strong>Mender</strong></th>
<th><strong>OSTree</strong></th>
<th><strong>Notes</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Programming Language</strong></td>
<td>C</td>
<td>Go</td>
<td>C</td>
<td>Go is not common for embedded systems</td>
<td></td>
</tr>
<tr class="even">
<td><strong>License</strong></td>
<td>MIT</td>
<td>Apache 2.0</td>
<td>GNU LGPLv2+</td>
<td>-</td>
<td></td>
</tr>
<tr class="odd">
<td><strong>OpenEmbedded Layer</strong></td>
<td>meta-rauc</td>
<td>meta-mender</td>
<td>meta-updater</td>
<td>-</td>
<td></td>
</tr>
<tr class="even">
<td><strong>Footprints</strong></td>
<td>Main binary is only approx. 512K</td>
<td>Main binary is about 6M</td>
<td>Main library is less than 1M</td>
<td>RAUC has a smaller size. [6]</td>
<td></td>
</tr>
<tr class="odd">
<td><strong>Device Layout Scheme</strong></td>
<td>Symmetric A/B or Asymmetric A/Recovery</td>
<td>Symmetric A/B only</td>
<td>Git-like object repository to record and deploy complete file system trees</td>
<td><p>RAUC is more flexible than Mender</p>
<p>OSTree is the most flexible one</p></td>
<td></td>
</tr>
<tr class="even">
<td><strong>Filesystem Types</strong></td>
<td><p>block devices: EXT4</p>
<p>MTD devices: UBIFS, UBIMG</p></td>
<td>No dependencies on a specific filesystem type, but depends on whether it is supported by the bootloader [1]</td>
<td><p>block devices: EXT4, BTRFS, XFS</p>
<p>MTD devices: supported but no implementation for a specified filesystem</p></td>
<td>Mender: less dependencies to certain filesystems than RAUC and OSTree</td>
<td></td>
</tr>
<tr class="odd">
<td><strong>Deploy Mechanism</strong></td>
<td><strong>Pre-Deploy Process </strong></td>
<td>N/A</td>
<td>N/A</td>
<td>Bare repository to archive repository migration is required</td>
<td><p>Mender needs commercial plans[2] to support some of the advanced features: delta update, gateway for distributed devices</p>
<p>OStree needs a migration from bare to archive repository before the packages are ready for clients</p>
<p>OSTree supports delta update naturally by its git-like repository</p></td>
</tr>
<tr class="even">
<td></td>
<td><strong>Packages Fetching</strong></td>
<td><p>Remote update: pull/push via HTTPS</p>
<p>Local update: from local media e.g. USB</p></td>
<td><p>Remote update: pull/push via HTTPS</p>
<p>Distributed devices require Mender Gateway [2] to connect to the server</p>
<p>Local update: from local media e.g. USB</p></td>
<td><p>Remote update: pull from a remote repository for a specific commit</p>
<p>Local update: a commit from the local repository</p></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td><strong>Streaming</strong></td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td><strong>Delta Update</strong></td>
<td>YES</td>
<td>Commercial plan is required [2]</td>
<td>YES</td>
<td></td>
</tr>
<tr class="odd">
<td><strong>Artifacts Management and Packaging</strong></td>
<td><strong>Artifact Format</strong></td>
<td><p>bundles (filesystem+manifest), followed by a signature plus signer's certificate (in CMS[4] format).</p>
<p>bundle types: Clear, Verity or Crypt</p></td>
<td>Mender Artifact (*.mender): software image+metadata</td>
<td>Git-like objects: metadata objects (commit objects, dirtree objects, dirmeta objects and xattrs objects) and content objects</td>
<td>-</td>
</tr>
<tr class="even">
<td></td>
<td><strong>Compression</strong></td>
<td>SquashFS image that supports mounting without unpacking</td>
<td>Artifact is not compressed, but filesystem image and metadata inside are gzip-compressed</td>
<td>Content objects are gzip-compressed. Metadata objects are uncompressed.</td>
<td>Mender/OSTree needs to unpack the gzip while RAUC can mount the SquashFS directly.</td>
</tr>
<tr class="odd">
<td></td>
<td><p><strong>Signing/</strong></p>
<p><strong>Verifying</strong></p></td>
<td><p>Signer's certificate (X.509 PEM) is defined in the system conf file [4].</p>
<p>Verify the signer's certificate against the linux keyring and then parse the public key to verify the bundle signature.</p>
<p>Signature algorithm: RSA 4096 or ECDSA 256</p></td>
<td><p>Signer's public key is defined in the system conf file [4].</p>
<p>Use the public key to verify the signature of artifacts.</p>
<p>Signature algorithm: RSA &gt;3072 or ECDSA 256.</p>
<p>Supports Google Cloud Key Management</p></td>
<td><p>Sign each of the commits using GPG.</p>
<p>Verifies the signature before deploying it.</p>
<p>The provisioning of the public key requires integration</p></td>
<td><p>RAUC verifies the public key against Linux keyring before using it to verify the signature while Mender has the support for cloud key management</p>
<p>OSTree is using GPG for signature without PKI but provision of the public key is the integrator's responsibility</p></td>
</tr>
<tr class="even">
<td></td>
<td><strong>Integrity Checks</strong></td>
<td>For type Verity, additional integrity check can be applied via dm-verity</td>
<td>N/A</td>
<td><p>Each content object has a checksum (SHA256) that includes the file content and metadata (uid, gid, mode and extended attributes).</p>
<p>An extension with IMA signatures and policies to provide additional integrity checks</p></td>
<td><p>RAUC provides options for filesystem encryption and integrity checks based on dm-crypt and dm-verity while Mender does not.</p>
<p>OSTree provides SHA256 checksum includes file content and metadata, plus IMA with additional file content integrity check and file content+metadata signature check, but without consideration on encryption</p></td>
</tr>
<tr class="odd">
<td></td>
<td><p><strong>Encrypt/</strong></p>
<p><strong>Decrypt</strong></p></td>
<td><p>For type Crypt, use dm-crypt to encrypt/decrypt bundle payload (symmetric key is a plain text in manifest, AES-256)</p>
<p>Manifest is encrypted by recipient's public key (RSA 4096, ECC 256)</p></td>
<td>N/A</td>
<td><p>N/A</p>
<p>OSTree does not have built-in support for encrypting repo/commit/package</p></td>
<td></td>
</tr>
<tr class="even">
<td><strong>Installation</strong></td>
<td><strong>System Update</strong></td>
<td><p>Slot is an abstraction to reflect a device, partition, volume or file</p>
<p>Slot grouping for deactivating/updating/reactive a group of slots, the operation within a slot group is atomic</p>
<p>Slot configuration described in system config file [4].</p>
<p>RAUC handles a mapping between slot type and image type with predefined methods for installation the bundles</p></td>
<td><p>Supports based on combinations of OS and hardware platforms.</p>
<p>Mender officially supports the most common Linux OSes, and has reference implementations for specific devices [5]</p></td>
<td><p>Supports recording and deploying complete (bootable) filesystem trees</p>
<p>Atomic updates are guaranteed by hard links</p></td>
<td><p>Mender: reference support for most of the popular OSes and hardwares and is easy to start with</p>
<p>RAUC: is more flexible by introducing the abstraction of "slot"</p>
<p>OSTree: has a fast and efficient update mechanism, due to its unique design of using atomic commits and hard links</p></td>
</tr>
<tr class="odd">
<td></td>
<td><strong>Application Update</strong></td>
<td></td>
<td>Extended per specific software package types by Update Modules, can be customized and installed separately</td>
<td><p>Need to integrate with a package system.</p>
<p>rpm-ostree is an example project</p></td>
<td><p>Mender: more flexible with the Update Modules</p>
<p>RAUS: only supports the installation method pre-defined</p>
<p>OSTree: similar principle as Mender, however integration with a package system is required</p></td>
</tr>
<tr class="even">
<td><strong>Bootloader Integration</strong></td>
<td><p>U-boot: script</p>
<p>GRUB: script</p>
<p>Barebox: boot chooser framework</p></td>
<td><p>GRUB: built-in supported by GRUB, no patch is needed</p>
<p>U-boot: Hooks</p></td>
<td>Commands and APIs to manage the bootloader configuration files and environment variables</td>
<td><p>Less integration work with GRUB and U-boot is required for Mender than RAUC</p>
<p>OSTree has less dependencies on specific bootloaders</p></td>
<td></td>
</tr>
<tr class="odd">
<td><strong>Update Rollback</strong></td>
<td>YES for Symmetric A/B</td>
<td>YES</td>
<td>YES.<br />
Quick and atomic rockback</td>
<td>System snapshots implemented by hard links allows OSTree to perform rollbacks in a fast and efficient manner with minimal overhead and risk of data loss</td>
<td></td>
</tr>
<tr class="even">
<td><strong>Backend Update System Compatibility</strong></td>
<td><p>rauc-hawkbit client for hawkBit</p>
<p>Upparat client for AWS IoT jobs</p>
<p>Both are separate projects ( Python apps and libraries)</p>
<p>D-Bus between RAUC and connect client</p></td>
<td><p>Tied to Mender Update server with features like Device Group, Phased Rollout Deployment, RBAC, Device Authentication [2]</p>
<p>Mender Connect client is ready for Mender Update Service.</p>
<p>D-Bus between Mender Client and Mender Connect</p></td>
<td><p>Reference design for Uptane:</p>
<p>aktualizr: C++ implementation of Uptane OTA update client</p>
<p>HERE OTA Connect: Uptane-compatible OTA server</p></td>
<td>For a demo with a backend service, Mender is ready-to-go, while RAUC/OSTree needs an integration with a specific connect client.</td>
<td></td>
</tr>
<tr class="odd">
<td><strong>Developer API</strong></td>
<td><strong>Device-Side</strong></td>
<td>D-Bus APIs</td>
<td>D-Bus APIs</td>
<td>D-Bus APIs</td>
<td><p>Mender: APIs for both device-side and server-side with the best API reference guide</p>
<p>RAUC: no reference implementation on server-side</p>
<p>OSTree: server-side APIs are for repository management only, not for general OTA management</p></td>
</tr>
<tr class="even">
<td></td>
<td><strong>Server-Side</strong></td>
<td>N/A</td>
<td>REST API for Mender server</td>
<td>Functions that can be used to implement an OSTree repository server</td>
<td></td>
</tr>
<tr class="odd">
<td><strong>Cryptographic API</strong></td>
<td>OpenSSL, PKCS#11</td>
<td>OpenSSL, PKCS#11</td>
<td>GPG, OpenSSL</td>
<td>OSTree is not using PKI</td>
<td></td>
</tr>
<tr class="even">
<td><strong>Command-Line Tool Availability</strong></td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>-</td>
<td></td>
</tr>
<tr class="odd">
<td><strong>CI/CD Pipeline Support For Deployment</strong></td>
<td>N/A</td>
<td>Ready for GitHub Actions, GitLab CI/CD, Azure DevOps</td>
<td>A prototype (with some supporting scripts) to promote commits from “dev” to “prod” through CI/CD pipeline</td>
<td>Mender is ready for demo on deploying via CI/CD pipeline while OSTree just provides a prototype for it</td>
<td></td>
</tr>
<tr class="even">
<td><strong>Documentation</strong></td>
<td><p>Usage guide, examples and integration guide for Yocto, PTXdist and buildroot</p>
<p>Example for local update (Symmetric A/B) is ready for testing with QEMU (with GRUB)</p></td>
<td><p>Good, clear and step-by-step documentation</p>
<p>Implementations and demos on Raspberry Pi, BeagleBone Black and QEMU</p>
<p>Examples for deploying updates via web-interface are ready for testing with QEMU</p></td>
<td><p>Concepts and prototypes on how to integrate with a build system and how to manage the repositories</p>
<p>API reference and manual</p></td>
<td><p>Mender: with the best documentation and is easy to start with an E2E OTA demo with backend</p>
<p>RAUC: only provides some certain examples to show a local update</p>
<p>OSTree: tends to provide ideas, prototypes on integration but with a steep learning curve, not user-friendly for beginners</p></td>
<td></td>
</tr>
<tr class="odd">
<td><strong>Version Compatibility</strong></td>
<td>Compatibility to old versions is limited to "a reasonable level"</td>
<td>The compatibility between different versions is well documented</td>
<td>Supports backward compatibility for older versions, but it is the responsibility of the developer to compare release notes</td>
<td>Mender has a clear picture on the compatibility between different versions while RAUC/OSTree does not</td>
<td></td>
</tr>
<tr class="even">
<td><strong>Customization</strong></td>
<td><p>Part of runtime behaviors of device-side clients can be configured via parameters of the system config file [4]</p>
<p>Handles (scripts) for pre-install or post-install can be defined in the system config file [4]</p>
<p>Hooks (scripts) can be defined in a bundle's manifest</p></td>
<td><p>Built-in customerization options are available through classes for both update image and Mender Client behaviors</p>
<p>Support customized State Scripts (root file system script or artifact script) which are able to be executed during transition of states.</p></td>
<td><p>OSTree is not a full update client, instead a library focused on git-like repository management</p>
<p>It is fully flexible for customization with an update client (e.g. aktualizr).</p></td>
<td><p>Mender has more flexibility with options/classes for both update image and client behaviors, State Scripts are more general and useful than pre/post-install scripts that RAUC is using</p>
<p>OSTree normally works with an external update client, itself doesn't provide more functionalities than repository management</p></td>
<td></td>
</tr>
</tbody>
</table>

## Summary Of Major Pros & Cons

### Mender

Advantages:

  - Ready for connecting with OTA backend service with an easy-to-use
    web-interface, ready for an end-to-end OTA demo with image
    management, update monitoring and deployment via CI/CD pipeline.

  - Less dependencies to certain filesystems than RAUC and OSTree.

  - Reference implementation with most of the popular OSes and
    hardwares, good documentation and is easy to start with.

  - APIs for both device-side and server-side with clear API reference
    guide.

  - Easy for customization with options and classes for adjusting both
    update image and client behaviors; State Scripts are more general
    and useful than pre/post-install scripts which RAUC is using;
    Update Modules provide more flexibility to extend installation
    methods of different package types for application updates.

  - Supports Google Cloud Key Management, allowing developers to sign
    artifacts without accessing the private signing key.

Disadvantages:

  - Firmly tied to Mender Update Service and advanced features (e.g.
    delta update, gateway for connection of distributed devices) may
    require purchasing a commercial plan.

  - Layout scheme supports “Symmetric A/B” only.

  - No consideration on filesystem encryption and integrity checks.

  - Mainly written in Go which is not common for embedded systems.

### RAUC

Advantages:

  - Flexible with different bundle types for different business
    requirements.

  - Relatively small binary size compared with Mender and OSTree.

  - Supports both “Symmetric A/B” and “Asymmetric A/Recovery” layout
    schemes.

  - Verifies the public key against Linux keyring before using it to
    verify the signature.

  - Provides options for filesystem encryption and integrity checks
    based on dm-crypt and dm-verity.

  - Easy for customization. Part of runtime behaviors of device-side
    clients can be configured. Hooks for pre/post-install or specific
    bundles can be defined.

Disadvantages:

  - Only supports pre-defined installation methods. Difficult to
    create a new installation method for a new package type or extend
    an existing one.

  - Needs to integrate with a specific connect client to work with an
    OTA backend service (e.g. rauc-hawkbit for hawkBit, Upparat for
    AWS).

  - No reference implementation on server-side.

  - Less customization flexibility compared with Mender.

### OSTree

Advantages:

  - Git-like object store allows to record and deploy multiple file
    system trees using binary deltas. It is designed to
    parallel-install multiple versions of multiple independent
    operating systems.

  - Each deployment is primarily composed of a set of hard links into
    the repository. This means each version is deduplicated; an
    upgrade process only costs disk space proportional to the new
    files, plus some constant overhead.

  - Quick and efficient update and rollback mechanism via system
    snapshots implemented by hard links allows OSTree to perform
    atomic updates/rollbacks in a fast and efficient manner with
    minimal overhead and risk of data loss.

  - SHA256 checksum includes file content and metadata, plus IMA with
    additional file content integrity check and file content plus
    metadata signature check.

  - Adopted by Uptane (Securing Software Updates for Automobiles)
    framework. A reference design for Uptane is available with
    aktualizr and HERE OTA Connect.

Disadvantages:

  - Steep learning curve, not user-friendly for beginners.

  - Not a full functioning update client, instead, a library focused
    on git-like repository management without additionally OTA
    management functions.

  - Needs to integrate with a specific connect client to work with an
    OTA backend service (e.g. aktualizr for HERE OTA Connect).

  - Needs to integrate with a package system (e.g. rpm-ostree).

  - No consideration on filesystem encryption.

  - Uses GPG for signature without PKI but provision of the public key
    is the integrator's responsibility.

  - Server-side APIs are for repository management only, not for
    general OTA management.

## Conclusion

In conclusion, RAUC, Mender, and OSTree are all software update
solutions that are widely used in the embedded systems world. They all
have their own strengths and weaknesses and the choice of which one to
use depends on the specific requirements of a project. If ease to start
with and a full functioning end-to-end OTA update management are
required, Mender may be a good choice. If quick atomic
upgrades/rollbacks and reliable version management are required, OSTree
may be more suitable. If a trade-off between flexibility and integration
effort is considered, RAUC may be a good selection.

# References

1.  U-Boot only supports UBI for raw flash.

2.  Mender Gateway, RBAC is available for Mender Enterprise plan only;
    Delta update is available for Mender Enterprise or Mender
    Professional plan only.

3.  Cryptographic Message Syntax.

4.  RAUC system config file is /etc/rauc/system.conf; Mender system
    config file is etc/mender/mender.conf.

5.  OS: Debian, Ubuntu and Raspberry Pi OS; Boards: Raspberry Pi 3
    Model B and B+, Raspberry Pi 4 Model B, Nvidia Jetson L4T, QEMU
    x86\_64+GRUB.

6.  These are rough calculations based on output from Yocto, and do
    not take into account dependencies, different build targets, etc.
